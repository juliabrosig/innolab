# },
# error = function(w)
#
# )
#   result = tryCatch({
#     expr
#   }, warning = function(w) {
#     warning-handler-code
#   }, error = function(e) {
#     error-handler-code
#   }, finally = {
#     cleanup-code
#   }
}
result_n[j, 1] = sum(result[, 2])
}
result_n
head(result)
# loeschen von alten var
rm()
# loeschen von alten var
rm(list=ls(all=TRUE))
B = 300
n = 30
p1 = 0.8
p2 = 0.9
n_vec = c(10, 20, 50, 100, 200)
rm(n)
# Ergebnisse fuer mehrere n (n_vec) aggregieren
result_n = matrix(data = NA, nrow = length(n_vec), ncol = 1)
# Ergebnismatrix erstellen
result = matrix(data = NA, nrow = B, ncol = 2)
for (j in 1:length(n_vec)){
n = n_vec[j]
# B-mal ziehen von 2 Stichproben und Berechnung t-Test
for (i in 1:B){
# Stichprobe fuer vB = 0.3 m/s ziehen
sample1 = sample(x = c(0, 1), size = n - 2, replace = TRUE, prob = c(1 - p1, p1))
sample1 = c(sample1, 0, 1)
sample2 = sample(x = c(0, 1), size = n - 2, replace = TRUE, prob = c(1 - p2, p2))
sample2 = c(sample2, 0, 1)
ttest = t.test(x = sample1, y = sample2)
result[i, 1] = ttest$p.value
result[i, 2] = ttest$p.value < 0.05
# # wenn zufaellig alle Elemente 0 sind, wird nochmal gezogen
# if (is.element(0, sample1)){
#   sample1 = sample(x = c(0, 1), size = n, replace = TRUE, prob = c(1 - p1, p1))
# }
# # wenn zufaellig alle Elemente 1 sind, wird nochmal gezogen
# if (is.element(1, sample1)){
#   sample1 = sample(x = c(0, 1), size = n, replace = TRUE, prob = c(1 - p1, p1))
# }
# # Stichprobe fuer vB = 0.5 m/s ziehen
# sample2 = sample(x = c(0, 1), size = n, replace = TRUE, prob = c(1 - p2, p2))
# # wenn zufaellig alle Elemente 0 sind, wird nochmal gezogen
# if (is.element(0, sample2)){
#   sample2 = sample(x = c(0, 1), size = n, replace = TRUE, prob = c(1 - p2, p2))
# }
# # wenn zufaellig alle Elemente 1 sind, wird nochmal gezogen
# if (is.element(1, sample2)){
#   sample2 = sample(x = c(0, 1), size = n, replace = TRUE, prob = c(1 - p2, p2))
# }
# # Berechnung t-Test mit sample1 und sample2
# tryCatch({
#   ttest = t.test(x = sample1, y = sample2)
#   result[i, 1] = ttest$p.value
#   result[i, 2] = ttest$p.value < 0.05
# },
# error = function(w)
#
# )
#   result = tryCatch({
#     expr
#   }, warning = function(w) {
#     warning-handler-code
#   }, error = function(e) {
#     error-handler-code
#   }, finally = {
#     cleanup-code
#   }
}
result_n[j, 1] = sum(result[, 2])
}
result_n
head(result)
# loeschen von alten var
rm(list=ls(all=TRUE))
# mit bootstrap 2 Stichproben ziehen
B = 300
p1 = 0.8
p2 = 0.9
n_vec = c(10, 20, 50, 100, 200)
# Ergebnisse fuer mehrere n (n_vec) aggregieren
result_n = matrix(data = NA, nrow = length(n_vec), ncol = 1)
# Ergebnismatrix erstellen
result = matrix(data = NA, nrow = B, ncol = 2)
for (j in 1:length(n_vec)){
n = n_vec[j]
# B-mal ziehen von 2 Stichproben und Berechnung t-Test
for (i in 1:B){
# Stichprobe fuer vB = 0.3 m/s ziehen
sample1 = sample(x = c(0, 1), size = n - 2, replace = TRUE, prob = c(1 - p1, p1))
sample1 = c(sample1, 0, 1)
sample2 = sample(x = c(0, 1), size = n - 2, replace = TRUE, prob = c(1 - p2, p2))
sample2 = c(sample2, 0, 1)
ttest = t.test(x = sample1, y = sample2)
result[i, 1] = ttest$p.value
result[i, 2] = ttest$p.value < 0.05
# # wenn zufaellig alle Elemente 0 sind, wird nochmal gezogen
# if (is.element(0, sample1)){
#   sample1 = sample(x = c(0, 1), size = n, replace = TRUE, prob = c(1 - p1, p1))
# }
# # wenn zufaellig alle Elemente 1 sind, wird nochmal gezogen
# if (is.element(1, sample1)){
#   sample1 = sample(x = c(0, 1), size = n, replace = TRUE, prob = c(1 - p1, p1))
# }
# # Stichprobe fuer vB = 0.5 m/s ziehen
# sample2 = sample(x = c(0, 1), size = n, replace = TRUE, prob = c(1 - p2, p2))
# # wenn zufaellig alle Elemente 0 sind, wird nochmal gezogen
# if (is.element(0, sample2)){
#   sample2 = sample(x = c(0, 1), size = n, replace = TRUE, prob = c(1 - p2, p2))
# }
# # wenn zufaellig alle Elemente 1 sind, wird nochmal gezogen
# if (is.element(1, sample2)){
#   sample2 = sample(x = c(0, 1), size = n, replace = TRUE, prob = c(1 - p2, p2))
# }
# # Berechnung t-Test mit sample1 und sample2
# tryCatch({
#   ttest = t.test(x = sample1, y = sample2)
#   result[i, 1] = ttest$p.value
#   result[i, 2] = ttest$p.value < 0.05
# },
# error = function(w)
#
# )
#   result = tryCatch({
#     expr
#   }, warning = function(w) {
#     warning-handler-code
#   }, error = function(e) {
#     error-handler-code
#   }, finally = {
#     cleanup-code
#   }
}
result_n[j, 1] = sum(result[, 2]) / B
}
result_n
# loeschen von alten var
rm(list=ls(all=TRUE))
# mit bootstrap 2 Stichproben ziehen
B = 300
p1 = 0.8
p2 = 0.9
n_vec = c(10, 20, 50, 100, 200)
# Ergebnisse fuer mehrere n (n_vec) aggregieren
result_n = matrix(data = NA, nrow = length(n_vec), ncol = 1)
# Ergebnismatrix erstellen
result = matrix(data = NA, nrow = B, ncol = 2)
for (j in 1:length(n_vec)){
n = n_vec[j]
# B-mal ziehen von 2 Stichproben und Berechnung t-Test
for (i in 1:B){
# Stichprobe fuer vB = 0.3 m/s ziehen
sample1 = sample(x = c(0, 1), size = n - 2, replace = TRUE, prob = c(1 - p1, p1))
sample1 = c(sample1, 0, 1)
sample2 = sample(x = c(0, 1), size = n - 2, replace = TRUE, prob = c(1 - p2, p2))
sample2 = c(sample2, 0, 1)
ttest = t.test(x = sample1, y = sample2)
result[i, 1] = ttest$p.value
result[i, 2] = ttest$p.value < 0.05
# # wenn zufaellig alle Elemente 0 sind, wird nochmal gezogen
# if (is.element(0, sample1)){
#   sample1 = sample(x = c(0, 1), size = n, replace = TRUE, prob = c(1 - p1, p1))
# }
# # wenn zufaellig alle Elemente 1 sind, wird nochmal gezogen
# if (is.element(1, sample1)){
#   sample1 = sample(x = c(0, 1), size = n, replace = TRUE, prob = c(1 - p1, p1))
# }
# # Stichprobe fuer vB = 0.5 m/s ziehen
# sample2 = sample(x = c(0, 1), size = n, replace = TRUE, prob = c(1 - p2, p2))
# # wenn zufaellig alle Elemente 0 sind, wird nochmal gezogen
# if (is.element(0, sample2)){
#   sample2 = sample(x = c(0, 1), size = n, replace = TRUE, prob = c(1 - p2, p2))
# }
# # wenn zufaellig alle Elemente 1 sind, wird nochmal gezogen
# if (is.element(1, sample2)){
#   sample2 = sample(x = c(0, 1), size = n, replace = TRUE, prob = c(1 - p2, p2))
# }
# # Berechnung t-Test mit sample1 und sample2
# tryCatch({
#   ttest = t.test(x = sample1, y = sample2)
#   result[i, 1] = ttest$p.value
#   result[i, 2] = ttest$p.value < 0.05
# },
# error = function(w)
#
# )
#   result = tryCatch({
#     expr
#   }, warning = function(w) {
#     warning-handler-code
#   }, error = function(e) {
#     error-handler-code
#   }, finally = {
#     cleanup-code
#   }
}
result_n[j, 1] = round(sum(result[, 2]) / B, 4)
}
result_n
# loeschen von alten var
rm(list=ls(all=TRUE))
# mit bootstrap 2 Stichproben ziehen
B = 300
p1 = 0.8
p2 = 0.9
n_vec = c(10, 20, 50, 100, 200)
# Ergebnisse fuer mehrere n (n_vec) aggregieren
result_n = matrix(data = NA, nrow = length(n_vec), ncol = 2)
# Ergebnismatrix erstellen
result = matrix(data = NA, nrow = B, ncol = 2)
for (j in 1:length(n_vec)){
n = n_vec[j]
# B-mal ziehen von 2 Stichproben und Berechnung t-Test
for (i in 1:B){
# Stichprobe fuer vB = 0.3 m/s ziehen
sample1 = sample(x = c(0, 1), size = n - 2, replace = TRUE, prob = c(1 - p1, p1))
sample1 = c(sample1, 0, 1)
sample2 = sample(x = c(0, 1), size = n - 2, replace = TRUE, prob = c(1 - p2, p2))
sample2 = c(sample2, 0, 1)
ttest = t.test(x = sample1, y = sample2)
result[i, 1] = ttest$p.value
result[i, 2] = ttest$p.value < 0.05
# # wenn zufaellig alle Elemente 0 sind, wird nochmal gezogen
# if (is.element(0, sample1)){
#   sample1 = sample(x = c(0, 1), size = n, replace = TRUE, prob = c(1 - p1, p1))
# }
# # wenn zufaellig alle Elemente 1 sind, wird nochmal gezogen
# if (is.element(1, sample1)){
#   sample1 = sample(x = c(0, 1), size = n, replace = TRUE, prob = c(1 - p1, p1))
# }
# # Stichprobe fuer vB = 0.5 m/s ziehen
# sample2 = sample(x = c(0, 1), size = n, replace = TRUE, prob = c(1 - p2, p2))
# # wenn zufaellig alle Elemente 0 sind, wird nochmal gezogen
# if (is.element(0, sample2)){
#   sample2 = sample(x = c(0, 1), size = n, replace = TRUE, prob = c(1 - p2, p2))
# }
# # wenn zufaellig alle Elemente 1 sind, wird nochmal gezogen
# if (is.element(1, sample2)){
#   sample2 = sample(x = c(0, 1), size = n, replace = TRUE, prob = c(1 - p2, p2))
# }
# # Berechnung t-Test mit sample1 und sample2
# tryCatch({
#   ttest = t.test(x = sample1, y = sample2)
#   result[i, 1] = ttest$p.value
#   result[i, 2] = ttest$p.value < 0.05
# },
# error = function(w)
#
# )
#   result = tryCatch({
#     expr
#   }, warning = function(w) {
#     warning-handler-code
#   }, error = function(e) {
#     error-handler-code
#   }, finally = {
#     cleanup-code
#   }
}
result_n[j, 1] = n_vec[j]
result_n[j, 2] = round(sum(result[, 2]) / B, 4)
}
result_n
colnames(result_n) = c("n", "sig")
result_n
library(mlbench)
sonar = data(Sonar)
head(sonar)
data(Sonar)
head(Sonar)
rm(sonar)
# initialize weights ----
ncol(Sonar)
weights = rep(c(0, 0.5), ncol(Sonar))
weights
weights = rep(sample(c(0, 0.5), replace = TRUE), ncol(Sonar))
weights
weights = c()
for (i in 1:ncol(Sonar)){
weights[[i]] = sample(x = c(0, 0.5), replace = TRUE)
}
weights
?sample
weights = sample(x = c(0, 0.5), size = ncol(Sonar), replace = TRUE)
weights
weights = sample(x = c(0, 1), size = ncol(Sonar), replace = TRUE)
weights
weights = sample(x = c(0:0.5), size = ncol(Sonar), replace = TRUE)
weights
weights = sample(x = 0:0.5, size = ncol(Sonar), replace = TRUE)
weights
t = 0:10
t
weights = sample(x = 0:50, size = ncol(Sonar), replace = TRUE)
weights
weights = weights / 100
weights
weights = sample(x = (0:50)/100, size = ncol(Sonar), replace = TRUE)
weights
data = Sonar
# initialize weights ----
weights = sample(x = (0:50) / 100, size = ncol(data), replace = TRUE)
str(Sonar)
# define X
X = Sonar[, -1]
str(X)
# define X
X = Sonar[, 1:60]
str(X)
# define X ----
X = data[, 1:60]
# initialize weights ----
weights = sample(x = (0:50) / 100, size = ncol(data), replace = TRUE)
# define biasTerm ----
biasTerm = c(0, -1)
biasTerm
## compute output of net = activation function (ReLU)
v = X * weights + biasTerm
v
X
str(X)
# define X ----
X = as.numeric(data[, 1:60])
# define X ----
X = as.numeric.matrix(data[, 1:60])
# define X ----
X = as.matrix(data[, 1:60])
str(X)
X + X
X %>% X
X %*% X
# define X ----
X = data[, 1:60]
head(X)
# define X ----
X = data.matrix(data[, 1:60])
str(X)
X %*% X
## compute output of net = activation function (ReLU)
v = X %*% weights + biasTerm
## compute output of net = activation function (ReLU)
v = X * weights + biasTerm
# define X ----
X = data.matrix(data[, 1:60])
# define biasTerm ----
biasTerm = c(0, -1)
# initialize weights ----
weights = sample(x = (0:50) / 100, size = ncol(data), replace = TRUE)
## compute output of net = activation function (ReLU)
v = X * weights + biasTerm
## compute output of net = activation function (ReLU)
v = X %*% weights + biasTerm
# define X ----
X = data.matrix(data[, 1:ncol(data)-1])
data = matrix(data = c(1:21), nrow = 4)
data = matrix(data = c(1:24), nrow = 4)
data
# define X ----
X = data.matrix(data[, 1:ncol(data)-1])
X
# define biasTerm ----
biasTerm = c(0, -1)
# initialize weights ----
weights = sample(x = (0:50) / 100, size = ncol(data), replace = TRUE)
weights
## compute output of net = activation function (ReLU)
v = X %*% weights + biasTerm
X
length(weights)
# initialize weights ----
weights = sample(x = (0:50) / 100, size = ncol(data) - 1, replace = TRUE)
## compute output of net = activation function (ReLU)
v = X %*% weights + biasTerm
v
actFct = max(0, v)
actFct
weights = rep(0, size = ncol(data) - 1)
weights
?rep
weights = rep(0, times = ncol(data) - 1)
weights
# (a) ----
?fft
fkt = function(t){
2.5 * sin(3 * t) + 4 * cos(1.2 * t) + t / 10
}
fft(fkt())
fft(fkt(t = 10))
# (b) ----
TSA::periodgram
# (b) ----
install.packages("TSA")
# (b) ----
# install.packages("TSA")
library(TSA)
fkt = 2.5 * sin(3 * t) + 4 * cos(1.2 * t) + t / 10
TSA::periodgram(fkt(t = 10))
# (b) ----
# install.packages("TSA")
library(TSA)
TSA::periodgram(fkt(t = 10))
foo = TSA::periodogram(fkt(t = 10))
TSA::periodogram(fkt(t = 10))
library(checkmate)
myOwnMean = function(vec){
assert(
checkNumeric(vec, lower = 1.3, upper = 2.4)
checkDataFrame(vec, types = "numeric")
)
m = sum(vec)/length(vec)
return(m)
}
myOwnMean = function(vec){
assert(
checkNumeric(vec, lower = 1.3, upper = 2.4),
checkDataFrame(vec, types = "numeric")
)
m = sum(vec)/length(vec)
return(m)
}
checkHeight = function(students.input = students, sex.specific = TRUE,
print.statement = FALSE) {
assertLogical(sex.specific)
assertDataFrame(students.input,
types = c("numeric", "numeric", "numeric", "factor", "character"),
min.rows = 4,
ncols = 5)
assertNumeric(students.input[, 3], lower = 1.3, upper = 2.4)
assertFactor(students.input[, 4], n.levels = 2)
# if sex.specific = T
if (sex.specific == TRUE) {
diff = apply(students.input, MARGIN = 1, FUN = function(s){
if (s["sex"] == "M") {
round(as.numeric(s["height"]) -
myOwnMean(students.input$height[students.input$sex == "M"]),
2) * 100
} else {
round(as.numeric(s["height"]) -
myOwnMean(students.input$height[students.input$sex == "F"]),
2) * 100
}
})
students.input$diff = diff
print("Yippie, I calculated the mean differences!")
return(students.input)
# if sex.specific = F
} else {
students.input$diff = round(students.input$height -
myOwnMean(students.input$height), 2) * 100
print("Yippie, I calculated the mean differences!")
return(students.input)
}
}
checkHeight()
### (1.5) - ok ----
devtools::install_github("juliafried/innolab")
library(innolab)
### (1.6) - ok ----
checkHeight()
getwd()
### (1.5) - ok ----
devtools::install_github("juliafried/innolab")
library(innolab)
### (1.6) - ok ----
checkHeight()
### (1.5) - ok ----
devtools::install_github("juliafried/innolab")
library(innolab)
### (1.6) - ok ----
checkHeight()
getwd()
setwd("C:/Users/Cbjf/desktop")
load("students.rda")
### (1.5) - ok ----
devtools::install_github("juliafried/innolab")
library(innolab)
### (1.6) - ok ----
checkHeight()
### (1.5) - ok ----
devtools::install_github("juliafried/innolab")
getwd()
setwd("C:/Users/Cbjf/desktop/innolab")
devtools::document()
library(innolab)
### (1.6) - ok ----
checkHeight()
### (1.7) - ok ----
setwd("C:/Users/Cbjf/Desktop")
### (1.6) - ok ----
checkHeight()
# (3) ----
devtools::use_testthat()
# (3) ----
install.packages("testthat")
library(testthat)
getwd()
setwd("C:/Users/Cbjf/Desktop/innolab")
devtools::use_testthat()
devtools::document()
devtools::test()
